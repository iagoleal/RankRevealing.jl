module RankRevealing

using LinearAlgebra

#########################
# General Utilities
#########################

rows(A) = size(A, 1)
cols(A) = size(A, 2)

# Matrix direct sum
# dsum(A, B) -> [A 0; 0 B]
dsum(A...) = cat(A...; dims=(1,2))

# Convert a list of vectors into a matrix with those vectors as rows.
rowstomatrix(xs) = reduce(vcat, map(x -> hcat(x...), xs))
colstomatrix(xs) = hcat(xs...)

# Return list containing a matrix' rows as vectors.
matrixtorows(A) = [A[x,:] for x in 1:rows(A)]
matrixtocols(A) = [A[:,x] for x in 1:cols(A)]

# In-place vertical matrix splitting
#  A -> [A1
#       ;A2]
function vsplit(X, k)
  m = rows(X)
  return view(X, 1:k, :), view(X, (k+1):m, :)
end

# In-place horizontal matrix splitting
# A -> [A1 A2]
function hsplit(X, k)
  n = cols(X)
  return view(X, :, 1:k), view(X, :, (k+1):n)
end

# In-place matrix splitting into 4 blocks
function msplit(A, mh = fld(rows(A),2), nh = fld(cols(A), 2))
  m, n = size(A)
  return view(A, 1:mh,     1:nh),
         view(A, 1:mh,     (nh+1):n),
         view(A, (mh+1):m, 1:nh),
         view(A, (mh+1):m, (nh+1):n)
end

########################
# Permutations
########################

function permcompose(p, q)
  n = length(p)
  if n != length(q)
    error("Tried to compose permutations over different dimensions.")
  end
  return [p[q[k]] for k in 1:n]
end

function permtranspose(p)
  pt = similar(p)
  for (i, v) in enumerate(p)
    pt[v] = i
  end
  return pt
end

# Transposition permutation for indices i and j
function transposition(n, i, j)
  perm = collect(1:n)
  perm[i], perm[j] = perm[j], perm[i]
  return perm
end

function perm2matrix(T, p)
  A = zeros(T, length(p), length(p))
  for (i, v) in enumerate(p)
    A[i, v] = 1
  end
  return A
end

# PLUQ decomposition
include("pluq.jl")

export pluq, PLUQ

# Generalized Rank Revealing decomposition
include("grr.jl")

export grr, GeneralizedRankRevealing, simple_rr, right_rr, left_rr

#####################
# Basis finding
#####################

export basis, intersection, sumspace

"""
    basis(xs)

Turn a set of vectors into a set of linearly independet vectors
spawning the same subspace.

**Warning**: Even if the input is already linearly independent,
             the returned basis may be composed of other vectors
             spawning the same subspace.
"""
function basis(xs)
  F = pluq(rowstomatrix(xs))
  return matrixtocols(F.U * F.Q)
end

"""
    intersection(xs, ys) -> vs

Given two sets of vectors,
calculate a basis for the intersection of the subspaces generated by them.
"""
function intersection(xs, ys)
  A = rowstomatrix(xs)
  B = rowstomatrix(ys)
  sol = grr(A, B)
  r3 = sol.r3
  basis_matrix = @view sol.H[(end-r3+1):end, :]
  return matrixtorows(basis_matrix)
end

"""
    sumspace(xs, ys) -> vs

Given two sets of vectors,
calculate a basis for the sum space of the subspaces generated by them.
"""
function sumspace(xs, ys)
  A = rowstomatrix(xs)
  B = rowstomatrix(ys)
  sol = grr(A, B)
  return matrixtorows(sol.H)
end

end # module
